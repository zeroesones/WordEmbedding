When dealing with a large DataFrame, the speed of the `extract_currency` function may become a bottleneck. Here are some ways to speed up the function:

1. **Compile the Regular Expression**: Compile the regular expression pattern once and reuse it to save compilation time.
  
2. **Use Pandas' `vectorize`**: Leverage vectorized operations in Pandas instead of Python loops.

3. **Multithreading**: Use Python's `concurrent.futures.ThreadPoolExecutor` to apply the function in parallel.

Here's an example incorporating these improvements:

```python
import pandas as pd
import re
from concurrent.futures import ThreadPoolExecutor

# Expanded currency map
currency_map = {
    # ... (same as before)
}

# Generate regular expression pattern and compile it
pattern_parts = []
for canonical, variations in currency_map.items():
    for v in variations:
        pattern_parts.append(re.escape(v))
pattern = '|'.join(pattern_parts)
compiled_pattern = re.compile(pattern, re.IGNORECASE)

# Function to extract and map currency
def extract_currency(text):
    matches = compiled_pattern.findall(text)
    extracted = []
    for match in matches:
        for canonical, variations in currency_map.items():
            if match.upper() in map(str.upper, variations):
                extracted.append(canonical)
    return ', '.join(set(extracted)) if extracted else None

# Create a sample DataFrame
df = pd.DataFrame({'text': ['Base Currency is USD or $', 
                            'you can say that the base currency is Japan Yen or ¥', 
                            'Euro or € is your base currency'] * 1000})  # Repeat rows for testing

# Use ThreadPoolExecutor for parallel execution
with ThreadPoolExecutor() as executor:
    df['extracted_currency'] = list(executor.map(extract_currency, df['text']))

# Show the DataFrame
print(df)
```

This code should be considerably faster, especially for large DataFrames.






Certainly, here's the complete code that includes the expanded `currency_map` dictionary:

```python
import pandas as pd
import re

# Expanded mapping of different forms of currency to canonical form
currency_map = {
    'USD': ['USD', 'US Dollar', r'\$', 'U.S. Dollar'],
    'EURO': ['EURO', '€', 'Euros', 'EUR'],
    'JPY': ['JPY', 'Japan Yen', '¥', 'Japanese Yen'],
    'GBP': ['GBP', 'Pound Sterling', '£', 'British Pound'],
    'AUD': ['AUD', 'Australian Dollar', 'A$', 'Aussie Dollar'],
    'CAD': ['CAD', 'Canadian Dollar', 'C$', 'Can$', 'Loonie'],
    'CHF': ['CHF', 'Swiss Franc', 'Fr.', 'SFr'],
    'CNY': ['CNY', 'Chinese Yuan', '¥', 'RMB', 'Renminbi'],
    'INR': ['INR', 'Indian Rupee', '₹'],
    'NZD': ['NZD', 'New Zealand Dollar', 'NZ$', 'Kiwi Dollar'],
    'SEK': ['SEK', 'Swedish Krona', 'kr'],
    'NOK': ['NOK', 'Norwegian Krone', 'kr'],
    'BRL': ['BRL', 'Brazilian Real', 'R$', 'Real'],
    'ZAR': ['ZAR', 'South African Rand', 'R'],
    'RUB': ['RUB', 'Russian Ruble', '₽', 'Rouble'],
    'MXN': ['MXN', 'Mexican Peso', '$'],
    'SGD': ['SGD', 'Singapore Dollar', 'S$', 'Sing$'],
    'HKD': ['HKD', 'Hong Kong Dollar', 'HK$', 'HKD$'],
    # Add more currencies and their variations here
}

# Generate regular expression pattern
pattern_parts = []
for canonical, variations in currency_map.items():
    for v in variations:
        pattern_parts.append(re.escape(v))
pattern = '|'.join(pattern_parts)

# Function to extract and map currency
def extract_currency(text):
    matches = re.findall(pattern, text)
    extracted = []
    for match in matches:
        for canonical, variations in currency_map.items():
            if match in variations:
                extracted.append(canonical)
    return ', '.join(set(extracted)) if extracted else None

# Create a sample DataFrame
df = pd.DataFrame({'text': ['Base Currency is USD or $',
                            'you can say that the base currency is Japan Yen or ¥',
                            'Euro or € is your base currency']})

# Extract and map currency
df['extracted_currency'] = df['text'].apply(extract_currency)

# Show the DataFrame
print(df)
```

This code will search for any of the forms of each currency in each row of the DataFrame and map them to their canonical form. It will then store the canonical form(s) in a new column called `extracted_currency`.



# Define a function to split the text based on delimiters
def split_text(row):
    text = row['Text']
    if isinstance(text, list):
        text = ' '.join(flatten_list(text))  # Flatten nested lists and convert to a single string

    delimiter_positions = {delimiter: -1 for delimiter in delimiters}
    split_texts = {delimiter: '' for delimiter in delimiters}

    for delimiter in delimiters:
        delimiter_position = text.rfind(delimiter)
        if delimiter_position >= 0:
            delimiter_positions[delimiter] = delimiter_position

    # Set up Month_Text
    if delimiter_positions['MONTH'] >= 0:
        split_texts['Month_Text'] = text[:delimiter_positions['MONTH']].strip()
    else:
        split_texts['Month_Text'] = ''

    # Set up Quarter_Text
    if delimiter_positions['QUARTER'] >= 0:
        if delimiter_positions['MONTH'] >= 0:
            split_texts['Quarter_Text'] = text[delimiter_positions['MONTH'] + len('MONTH'):delimiter_positions['QUARTER']].strip()
        else:
            split_texts['Quarter_Text'] = text[:delimiter_positions['QUARTER']].strip()
    else:
        split_texts['Quarter_Text'] = ''

    # Set up Year_Text
    if delimiter_positions['YEAR'] >= 0:
        if delimiter_positions['QUARTER'] >= 0:
            split_texts['Year_Text'] = text[delimiter_positions['QUARTER'] + len('QUARTER'):delimiter_positions['YEAR']].strip()
        elif delimiter_positions['MONTH'] >= 0:
            split_texts['Year_Text'] = text[delimiter_positions['MONTH'] + len('MONTH'):delimiter_positions['YEAR']].strip()
        else:
            split_texts['Year_Text'] = text[:delimiter_positions['YEAR']].strip()
    else:
        split_texts['Year_Text'] = ''

    return pd.Series({
        'RefId': row['RefId'],
        'RefRefId': row['RefRefId'],
        'Text': text,
        'Month_Text': split_texts['Month_Text'],
        'Quarter_Text': split_texts['Quarter_Text'],
        'Year_Text': split_texts['Year_Text']
    })





def flatten_list(lst):
    flattened = []
    for item in lst:
        if isinstance(item, list):
            flattened.extend(flatten_list(item))
        else:
            flattened.append(item)
    return flattened

# Define a function to split the text based on delimiters
def split_text(row):
    text = row['Text']
    if isinstance(text, list):
        text = ' '.join(flatten_list(text))  # Flatten nested lists and convert to a single string




import pandas as pd

# Define the delimiters
delimiters = ['MONTH', 'QUARTER', 'YEAR']

# Define a function to split the text based on delimiters
def split_text(row):
    text = row['Text']
    delimiter_positions = {delimiter: -1 for delimiter in delimiters}
    split_texts = {delimiter: '' for delimiter in delimiters}

    for delimiter in delimiters:
        delimiter_position = text.rfind(delimiter)
        if delimiter_position >= 0:
            delimiter_positions[delimiter] = delimiter_position

    # Set up Month_Text
    if delimiter_positions['MONTH'] >= 0:
        split_texts['Month_Text'] = text[:delimiter_positions['MONTH']].strip()
    else:
        split_texts['Month_Text'] = text

    # Set up Quarter_Text
    if delimiter_positions['QUARTER'] >= 0:
        if delimiter_positions['MONTH'] >= 0:
            split_texts['Quarter_Text'] = text[delimiter_positions['MONTH']:delimiter_positions['QUARTER']].strip()
        else:
            split_texts['Quarter_Text'] = text[:delimiter_positions['QUARTER']].strip()
    else:
        split_texts['Quarter_Text'] = ''

    # Set up Year_Text
    if delimiter_positions['YEAR'] >= 0:
        if delimiter_positions['QUARTER'] >= 0:
            split_texts['Year_Text'] = text[delimiter_positions['QUARTER']:delimiter_positions['YEAR']].strip()
        else:
            split_texts['Year_Text'] = text[:delimiter_positions['YEAR']].strip()
    else:
        split_texts['Year_Text'] = ''

    return pd.Series({
        'RefId': row['RefId'],
        'RefRefId': row['RefRefId'],
        'Text': text,
        'Month_Text': split_texts['Month_Text'],
        'Quarter_Text': split_texts['Quarter_Text'],
        'Year_Text': split_texts['Year_Text']
    })

# Sample dataframe
data = {'RefId': [1, 2, 3],
        'RefRefId': [101, 102, 103],
        'Text': ["thirty days period 15% 30 days period 35% thirty day 58% three month",
                 "NAV is 10% immediately preceding three months period 15% three month period 35% 3 month",
                 '']}
df = pd.DataFrame(data)

# Apply the function to each row and create a new dataframe
result_df = df.apply(split_text, axis=1)




































pattern = r'\b(?:' + '|'.join(Month + Quarter) + r')\b'
    return re.sub(pattern, replace, text, flags=re.IGNORECASE) if text else text

import pandas as pd
import re

# Sample dataframe
data = {'RefID': [1, 2, 3],
        'Text':[[["thirty days period 15% 30 days period 35% thirty day 58% three month"]],
                [[ "NAV is 10% immediately preceding three months period 15% three month period 35% 3 month"]],
                 ['']]}
df = pd.DataFrame(data)

# Lists of patterns
Month = ['30 days', 'thirty day']
Quarter = ['three month', '3 month']

# Define the append_text function to handle the replacement
def append_text(text_list):
    def replace(match):
        if match.group() in Month:
            return match.group() + ' MONTH'
        elif match.group() in Quarter:
            return match.group() + ' QUARTER'

    if isinstance(text_list, list):
        updated_text_list = []
        for text in text_list:
            if isinstance(text, list):
                updated_text = []
                for sub_list in text:
                    if isinstance(sub_list, str):
                        pattern = r'\b(?:' + '|'.join(map(re.escape, Month + Quarter)) + r')\b'
                        updated_text.append(re.sub(pattern, replace, sub_list, flags=re.IGNORECASE))
                    else:
                        updated_text.append(sub_list)
                updated_text_list.append(updated_text)
            else:
                updated_text_list.append(text)
        return updated_text_list
    else:
        return text_list

# Apply the function to each row in the 'Text' column
df['Text'] = df['Text'].apply(append_text)

print(df)

